"use strict";var _interopRequireDefault=require("@babel/runtime-corejs3/helpers/interopRequireDefault");require("core-js/modules/es.array.iterator");require("core-js/modules/es.promise");require("core-js/modules/es.promise.finally");require("core-js/modules/web.dom-collections.iterator");exports.__esModule=true;exports.default=exports.Deferral=exports.PromiseState=void 0;var _filter2=_interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));var _map2=_interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));var _promise=_interopRequireDefault(require("@babel/runtime-corejs3/core-js/promise"));var _toStringTag=_interopRequireDefault(require("@babel/runtime-corejs3/core-js/symbol/to-string-tag"));var _toString2=_interopRequireDefault(require("lodash/toString"));var _filter3=_interopRequireDefault(require("lodash/filter"));var _map3=_interopRequireDefault(require("lodash/map"));var _isFunction2=_interopRequireDefault(require("lodash/isFunction"));var _isEmpty2=_interopRequireDefault(require("lodash/isEmpty"));var _isNil2=_interopRequireDefault(require("lodash/isNil"));var _pull2=_interopRequireDefault(require("lodash/pull"));var _forEach2=_interopRequireDefault(require("lodash/forEach"));var _once2=_interopRequireDefault(require("lodash/once"));var _identity2=_interopRequireDefault(require("lodash/identity"));var _toArray2=_interopRequireDefault(require("lodash/toArray"));var _castArray2=_interopRequireDefault(require("lodash/castArray"));var _clone2=_interopRequireDefault(require("lodash/clone"));var _defer2=_interopRequireDefault(require("lodash/defer"));var _isError2=_interopRequireDefault(require("lodash/isError"));let _Symbol$toStringTag;function isError(it){return(0,_isError2.default)(it)}var PromiseState;exports.PromiseState=PromiseState;(function(PromiseState){PromiseState["Pending"]="pending";PromiseState["Resolving"]="resolving";PromiseState["Resolved"]="resolved";PromiseState["Rejecting"]="rejecting";PromiseState["Rejected"]="rejected"})(PromiseState||(exports.PromiseState=PromiseState={}));class Deferral{get state(){return this.stateValue}get isSettling(){switch(this.stateValue){case PromiseState.Resolving:return true;case PromiseState.Rejecting:return true;default:return false;}}get isResolved(){return this.stateValue===PromiseState.Resolved}get isRejected(){return this.stateValue===PromiseState.Rejected}resolve(it){const{resolver}=this;if(resolver){try{const{rejector}=this;this.stateValue=PromiseState.Resolving;(0,_defer2.default)(()=>{try{resolver(it);this.stateValue=PromiseState.Resolved}catch(e){if(rejector){this.rejector=rejector;this.reject(e)}else{console.warn(`Uncaught exception during resolution`,e)}}})}catch(e){this.reject(e)}finally{this.resolver=null;this.rejector=null}}return this.promise}reject(e){const{rejector}=this;if(rejector){try{this.stateValue=PromiseState.Rejecting;(0,_defer2.default)(()=>{try{rejector(e)}finally{this.stateValue=PromiseState.Rejected}})}finally{this.resolver=null;this.rejector=null}}return this.promise}constructor(){this.promise=void 0;this.stateValue=PromiseState.Pending;this.resolver=null;this.rejector=null;this.promise=FunPromise.new((resolve,reject)=>{this.resolver=resolve;this.rejector=reject})}}exports.Deferral=Deferral;_Symbol$toStringTag=_toStringTag.default;class FunPromise{constructor(wrapped){this.wrapped=void 0;this[_Symbol$toStringTag]=void 0;this.wrapped=wrapped;this[_toStringTag.default]=wrapped[_toStringTag.default]}static wrap(promise){if(promise instanceof FunPromise){return promise}else if(promise instanceof _promise.default){return new FunPromise(promise)}else{return new FunPromise(new _promise.default(resolve=>resolve(promise)))}}static resolve(it){if(it instanceof _promise.default||it instanceof FunPromise){return FunPromise.wrap(it)}else{return FunPromise.new(resolver=>resolver(it))}}static new(executor){return FunPromise.wrap(new _promise.default(executor))}processArray(handler){return FunPromise.wrap(this.arrayify().wrapped.then(async inputIterable=>{const ary=(0,_clone2.default)((0,_castArray2.default)(inputIterable));const resultIterable=handler(ary);return _promise.default.all((0,_toArray2.default)(resultIterable))}))}reduceArray(handler){const toWrap=this.arrayify().wrapped.then(handler);return FunPromise.wrap(toWrap)}static try(fn){return FunPromise.new(resolver=>resolver(fn()))}static all(them){return FunPromise.resolve(them).all()}all(){return this.processArray(_identity2.default)}static race(them,errorHandler){return FunPromise.resolve(them).race(errorHandler)}race(errorHandler){return this.reduceArray(ary=>new _promise.default(async(resolver,rejector)=>{const doResolve=(0,_once2.default)(resolver);(0,_forEach2.default)(ary,it=>FunPromise.resolve(it).tapFinally(()=>{(0,_pull2.default)(ary,it)}).then(doResolve,e=>{if(!(0,_isNil2.default)(errorHandler))errorHandler(e);if((0,_isEmpty2.default)(ary))rejector(e)}))}))}static coalesce(them){return FunPromise.resolve(them).coalesce()}coalesce(){return this.reduceArray(async ary=>{var _lastRejection;let lastRejection=null;while(!(0,_isEmpty2.default)(ary)){try{const factory=ary.shift();if((0,_isFunction2.default)(factory)){return await factory()}}catch(e){lastRejection=e}}throw(_lastRejection=lastRejection)!=null?_lastRejection:new Error("No values found to coalesce")})}static map(them,mapper){var _context;return(0,_map2.default)(_context=FunPromise.resolve(them)).call(_context,mapper)}map(mapper){return this.reduceArray(ary=>_promise.default.all((0,_map3.default)(ary,mapper)))}static mapSeq(them,mapper){var _context2;return(0,_map2.default)(_context2=FunPromise.resolve(them)).call(_context2,mapper)}mapSeq(mapper){return this.reduceArray(async ary=>{const result=[];result.length=ary.length;while(!(0,_isEmpty2.default)(ary)){result.push(mapper(await ary.shift()))}return result})}static fold(them,initialValue,handler){return FunPromise.resolve(them).fold(initialValue,handler)}fold(initialValue,handler){return this.reduceArray(ary=>{let memo=FunPromise.resolve(initialValue);return _promise.default.all((0,_map3.default)(ary,async it=>{const result=await it;memo=memo.then(newMemo=>handler(newMemo,result))})).then(async()=>await memo)})}static foldSeq(them,initialValue,handler){return FunPromise.resolve(them).fold(initialValue,handler)}foldSeq(initialValue,handler){return this.reduceArray(ary=>{let memoPromise=FunPromise.resolve(initialValue);while(!(0,_isEmpty2.default)(ary)){const nextPromise=ary.shift();memoPromise=memoPromise.then(async memo=>handler(memo,await nextPromise))}return memoPromise})}static filter(them,filter){var _context3;return(0,_filter2.default)(_context3=FunPromise.resolve(them)).call(_context3,filter)}filter(test){return this.processArray(async ary=>{const testResults=await _promise.default.all((0,_map3.default)(ary,test));return(0,_filter3.default)(ary,(item,idx)=>{item;return testResults[idx]})})}static filterSeq(them,filter){return FunPromise.resolve(them).filterSeq(filter)}filterSeq(test){return this.processArray(async ary=>{const result=[];while(!(0,_isEmpty2.default)(ary)){const it=ary.shift();if(await test(it))result.push(it)}return result})}then(onfulfilled,onrejected){return FunPromise.wrap(this.wrapped.then(onfulfilled,onrejected))}catch(handler){return FunPromise.wrap(this.wrapped.catch(handler))}finally(handler){return FunPromise.wrap(this.wrapped.finally(handler))}catchError(handler=_identity2.default){return this.catch(reason=>{if((0,_isNil2.default)(reason)){throw new Error(`Promise was rejected without a reason`)}else if(isError(reason)){handler(reason)}else{handler(new Error(`Promise was rejected; expected Error, but saw: ${(0,_toString2.default)(reason)} (${typeof reason})`))}})}tap(handler){return this.then(async result=>{await handler(result);return result})}tapCatch(handler){return this.catchError(e=>FunPromise.try(()=>handler(e)).finally(()=>{throw e}))}tapFinally(handler,errHandler){return this.tap(handler).tapCatch(errHandler!=null?errHandler:handler)}return(value){return FunPromise.wrap(this.wrapped.then(()=>value))}arrayify(){return FunPromise.wrap(this.wrapped.then(iterable=>(0,_toArray2.default)(iterable)))}simplify(){return this}}exports.default=FunPromise;