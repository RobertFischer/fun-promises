{"version":3,"file":"deferral.js","sourceRoot":"","sources":["../../../../src/deferral.ts"],"names":[],"mappings":"AAAA,cAAc;;;;;;;;;;;;IAEd,+CAAuC;IACvC,sCAAgC;IAGhC;;;;;;;;OAQG;IACH,MAAqB,QAAQ;QAsC5B;;;WAGG;QACH;YAzCA;;eAEG;YACH;;;;;eAAgC;YAEhC;;eAEG;YACH;;;;uBAAmE,IAAI;eAAC;YAExE;;eAEG;YACH;;;;uBAA8D,IAAI;eAAC;YA6BlE,IAAI,CAAC,OAAO,GAAG,IAAI,qBAAU,CAC5B,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBAC/B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;gBACxB,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC;YACxB,CAAC,CAAC,CACF,CAAC;QACH,CAAC;QAjCD;;WAEG;QACH,OAAO,CAAC,EAAE;YACT,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;YAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACrB,IAAI,QAAQ;gBAAE,QAAQ,CAAC,EAAE,CAAC,CAAC;YAC3B,OAAO,IAAI,CAAC,OAAO,CAAC;QACrB,CAAC;QAED;;WAEG;QACH,MAAM,CAAC,CAAQ;YACd,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;YAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;YACrB,IAAI,QAAQ;gBAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC1B,OAAO,IAAI,CAAC,OAAO,CAAC;QACrB,CAAC;QAeD;;WAEG;QACH,IAAI,WAAW;YACd,OAAO,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC;QAC/B,CAAC;QAED;;;WAGG;QACH,MAAM;YACL,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;gBACtB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,cAAK,CAAC,CAAC,CAAC,wCAAwC;gBACnE,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC,CAAC;gBACjD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;gBACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;aACrB;QACF,CAAC;KACD;IAtED,2BAsEC","sourcesContent":["/** @format */\n\nimport FunPromise from \"./fun-promise\";\nimport _noop from \"lodash/noop\";\nimport type { Promisable } from \"./types\";\n\n/**\n * A class that is an \"inside-out\" [[`FunPromise`]]: the `resolve` and `reject` functions\n * from the callback are exposed as properties, and are therefore able to be called by\n * caller's code.\n *\n * Note that after the first call to either `resolve` or `reject`, the underlying promise\n * is settled. Any subsequent call to either `resolve` or `reject` is guaranteed to be\n * a no-op.\n */\nexport default class Deferral<T> {\n\t/**\n\t * The promise whose state is determined by `resolve` and `reject`.\n\t */\n\treadonly promise: FunPromise<T>;\n\n\t/**\n\t * The function used to resolve [[`promise`]].\n\t */\n\tprivate resolver: (it: Promisable<T>) => Promisable<void> | null = null;\n\n\t/**\n\t * The function used to reject [[`promise`]].\n\t */\n\tprivate rejector: (err: unknown) => Promisable<void> | null = null;\n\n\t/**\n\t * Resolves `promise` with the given value.\n\t */\n\tresolve(it) {\n\t\tconst { resolver } = this;\n\t\tthis.resolver = null;\n\t\tthis.rejector = null;\n\t\tif (resolver) resolver(it);\n\t\treturn this.promise;\n\t}\n\n\t/**\n\t * Rejects `promise` with the given cause.\n\t */\n\treject(e: Error) {\n\t\tconst { rejector } = this;\n\t\tthis.resolver = null;\n\t\tthis.rejector = null;\n\t\tif (rejector) rejector(e);\n\t\treturn this.promise;\n\t}\n\n\t/**\n\t * Constructs a new promise and exposes its resolve\n\t * and reject functions.\n\t */\n\tconstructor() {\n\t\tthis.promise = new FunPromise(\n\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\tthis.resolver = resolve;\n\t\t\t\tthis.rejector = reject;\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Whether or not the deferral is cancelled.\n\t */\n\tget isCancelled() {\n\t\treturn this.resolver === null;\n\t}\n\n\t/**\n\t * Cancels the deferral.  If the deferral is not settled, its callbacks will\n\t * never be called. If the deferral is settled or cancelled, this is a noop.\n\t */\n\tcancel() {\n\t\tif (!this.isCancelled) {\n\t\t\tthis.promise.catch(_noop); // Suppress \"UnhandledException\" errors.\n\t\t\tthis.reject(new Error(`Deferral was cancelled`));\n\t\t\tthis.resolver = null;\n\t\t\tthis.rejector = null;\n\t\t}\n\t}\n}\n"]}