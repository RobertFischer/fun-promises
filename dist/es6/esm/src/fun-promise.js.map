{"version":3,"file":"fun-promise.js","sourceRoot":"","sources":["../../../../src/fun-promise.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @format\n */\n\n/* What follows ensures that we have the entire Promise API implemented */\n/// <reference path=\"../node_modules/typescript/lib/lib.es5.d.ts\" />\n/// <reference path=\"../node_modules/typescript/lib/lib.es2015.iterable.d.ts\" />\n/// <reference path=\"../node_modules/typescript/lib/lib.es2015.promise.d.ts\" />\n/// <reference path=\"../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts\" />\n/// <reference path=\"../node_modules/typescript/lib/lib.es2018.promise.d.ts\" />\n/// <reference path=\"../node_modules/typescript/lib/lib.es2020.promise.d.ts\" />\n/// <reference path=\"../node_modules/typescript/lib/lib.esnext.promise.d.ts\" />\n\nimport type { Promisable, PromisableIterable, Unpromise, Item } from \"./types\";\nimport { NestedError } from \"@robertfischer/ts-nested-error\";\n\nimport _defer from \"lodash/defer\";\nimport _delay from \"lodash/delay\";\nimport _filter from \"lodash/filter\";\nimport _flatten from \"lodash/flatten\";\nimport _identity from \"lodash/identity\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _isError from \"lodash/isError\";\nimport _isFunction from \"lodash/isFunction\";\nimport _isNil from \"lodash/isNil\";\nimport _map from \"lodash/map\";\nimport _negate from \"lodash/negate\";\nimport _noop from \"lodash/noop\";\nimport _toArray from \"lodash/toArray\";\n\n// import Debug from \"debug\";\n// const debug = Debug(\"fun-promises\");\n\n/**\n * The class that you should use instead of `Promise`.  It implements the `Promise` API, so it should be a drop-in replacement.\n */\nexport default class FunPromise<T> implements Promise<T> {\n\t/**\n\t * Constructor, which takes the promise to wrap.\n\t */\n\tconstructor(protected readonly wrapped: Promise<T>) {}\n\n\t/**\n\t * Takes a value (or a promise of a value) and returns a promise wrapping\n\t * it.\n\t */\n\tstatic resolve<T = void>(value?: Promisable<T>): FunPromise<T> {\n\t\treturn new FunPromise(Promise.resolve(value));\n\t}\n\n\t/**\n\t * Takes a value (or a promise of a value) and resolves to the new value,\n\t * disregarding any previous resolution value.\n\t *\n\t */\n\tresolve<T2 = void>(value?: Promisable<T2>): FunPromise<T2> {\n\t\treturn new FunPromise(this.wrapped.then(() => value));\n\t}\n\n\t/**\n\t * Takes a value (or a promise of a value) and returns a promise rejecting\n\t * with that value, after unwrapping as many layers of `PromiseLike`\n\t * wrappers as necessary.\n\t */\n\tstatic reject(value?: unknown): FunPromise<never> {\n\t\treturn new FunPromise(Promise.reject(value));\n\t}\n\n\t/**\n\t * Takes a value (or a promise of a value) and returns a promise rejecting\n\t * with that value, after unwrapping as many layers of `PromiseLike`\n\t * wrappers as necessary.  This disregards any existing status.\n\t */\n\treject(value?: unknown): FunPromise<never> {\n\t\treturn FunPromise.reject(value);\n\t}\n\n\t/**\n\t * Attaches callbacks for the resolution and/or rejection of the Promise.\n\t * @param onfulfilled The optional callback to execute when the Promise is resolved.\n\t * @param onrejected The optional callback to execute when the Promise is rejected.  If provided, the result of this callback is the new resolution value, and this promise is resolved, not rejected.\n\t * @returns A Promise for the completion of which ever callback is executed.\n\t */\n\tthen<TResult1 = T>(\n\t\tonfulfilled: (value: T) => Promisable<TResult1>\n\t): FunPromise<TResult1>;\n\tthen<TResult1 = T, TResult2 = TResult1>(\n\t\tonfulfilled: (value: T) => Promisable<TResult1>,\n\t\tonrejected: (reason: any) => Promisable<TResult2>\n\t): FunPromise<TResult1 | TResult2>;\n\tthen<TResult1 = T, TResult2 = TResult1>(\n\t\tonfulfilled: (value: T) => Promisable<TResult1>,\n\t\tonrejected?: (reason: any) => Promisable<TResult2>\n\t): FunPromise<TResult1 | TResult2> {\n\t\tif (_isNil(onrejected)) {\n\t\t\treturn new FunPromise(this.wrapped.then(onfulfilled));\n\t\t} else {\n\t\t\treturn new FunPromise(this.wrapped.then(onfulfilled, onrejected));\n\t\t}\n\t}\n\n\t/**\n\t * Attaches a callback for only the rejection of the Promise.\n\t * @param onrejected The callback to execute when the Promise is rejected.\n\t * @returns A Promise for the completion of the callback.\n\t */\n\tcatch<TResult = never>(\n\t\tonrejected: (reason: any) => Promisable<TResult> = _identity\n\t): FunPromise<T | TResult> {\n\t\treturn new FunPromise(this.wrapped.catch(onrejected));\n\t}\n\n\t/**\n\t * Creates a Promise that is resolved with an array of results when all of the\n\t * provided Promises resolve, or rejected when any Promise is rejected.\n\t * @param values An array of Promises.\n\t * @returns A new Promise.\n\t */\n\tstatic all<T>(values: PromisableIterable<T>): FunPromise<T[]>;\n\tstatic all<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(\n\t\tvalues: [\n\t\t\tPromisable<T1>,\n\t\t\tPromisable<T2>,\n\t\t\tPromisable<T3>,\n\t\t\tPromisable<T4>,\n\t\t\tPromisable<T5>,\n\t\t\tPromisable<T6>,\n\t\t\tPromisable<T7>,\n\t\t\tPromisable<T8>,\n\t\t\tPromisable<T9>,\n\t\t\tPromisable<T10>\n\t\t]\n\t): FunPromise<[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]>;\n\tstatic all<T1, T2, T3, T4, T5, T6, T7, T8, T9>(\n\t\tvalues: [\n\t\t\tPromisable<T1>,\n\t\t\tPromisable<T2>,\n\t\t\tPromisable<T3>,\n\t\t\tPromisable<T4>,\n\t\t\tPromisable<T5>,\n\t\t\tPromisable<T6>,\n\t\t\tPromisable<T7>,\n\t\t\tPromisable<T8>,\n\t\t\tPromisable<T9>\n\t\t]\n\t): FunPromise<[T1, T2, T3, T4, T5, T6, T7, T8, T9]>;\n\tstatic all<T1, T2, T3, T4, T5, T6, T7, T8>(\n\t\tvalues: [\n\t\t\tPromisable<T1>,\n\t\t\tPromisable<T2>,\n\t\t\tPromisable<T3>,\n\t\t\tPromisable<T4>,\n\t\t\tPromisable<T5>,\n\t\t\tPromisable<T6>,\n\t\t\tPromisable<T7>,\n\t\t\tPromisable<T8>\n\t\t]\n\t): FunPromise<[T1, T2, T3, T4, T5, T6, T7, T8]>;\n\tstatic all<T1, T2, T3, T4, T5, T6, T7>(\n\t\tvalues: [\n\t\t\tPromisable<T1>,\n\t\t\tPromisable<T2>,\n\t\t\tPromisable<T3>,\n\t\t\tPromisable<T4>,\n\t\t\tPromisable<T5>,\n\t\t\tPromisable<T6>,\n\t\t\tPromisable<T7>\n\t\t]\n\t): FunPromise<[T1, T2, T3, T4, T5, T6, T7]>;\n\tstatic all<T1, T2, T3, T4, T5, T6>(\n\t\tvalues: [\n\t\t\tPromisable<T1>,\n\t\t\tPromisable<T2>,\n\t\t\tPromisable<T3>,\n\t\t\tPromisable<T4>,\n\t\t\tPromisable<T5>,\n\t\t\tPromisable<T6>\n\t\t]\n\t): FunPromise<[T1, T2, T3, T4, T5, T6]>;\n\tstatic all<T1, T2, T3, T4, T5>(\n\t\tvalues: [\n\t\t\tPromisable<T1>,\n\t\t\tPromisable<T2>,\n\t\t\tPromisable<T3>,\n\t\t\tPromisable<T4>,\n\t\t\tPromisable<T5>\n\t\t]\n\t): FunPromise<[T1, T2, T3, T4, T5]>;\n\tstatic all<T1, T2, T3, T4>(\n\t\tvalues: [Promisable<T1>, Promisable<T2>, Promisable<T3>, Promisable<T4>]\n\t): FunPromise<[T1, T2, T3, T4]>;\n\tstatic all<T1, T2, T3>(\n\t\tvalues: [Promisable<T1>, Promisable<T2>, Promisable<T3>]\n\t): FunPromise<[T1, T2, T3]>;\n\tstatic all<T1, T2>(\n\t\tvalues: [Promisable<T1>, Promisable<T2>]\n\t): FunPromise<[T1, T2]>;\n\tstatic all<T1>(values: [Promisable<T1>]): FunPromise<[T1]>;\n\tstatic all(...values: any[]): any {\n\t\treturn FunPromise.resolve(_flatten(values)).all();\n\t}\n\tall(): FunPromise<Item<T>[]> {\n\t\treturn this.arrayify(true);\n\t}\n\n\t/**\n\t * Given a function (or a promise of a function) that returns a value (or a promise of a value),\n\t * create a promise that executes the function and returns the value. If executing the function\n\t * throws an exception, then that exception becomes the rejection of the promise.\n\t *\n\t * Any arguments after the first will be passed into the function when it is invoked. If they are\n\t * a `PromiseLike`, then they will be resolved and the resolution value will be passed into the\n\t * function instead.\n\t *\n\t * This function is really useful in the following cases:\n\t *   1. to [avoid releasing Zalgo](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n\t *   2. when you want to create a `FunPromise` based on an `async` function\n\t *   3. when you want to create a `FunPromise` based on a normal function\n\t */\n\tstatic try<T, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8>(\n\t\tsource: Promisable<\n\t\t\t(\n\t\t\t\targ1: Arg1,\n\t\t\t\targ2: Arg2,\n\t\t\t\targ3: Arg3,\n\t\t\t\targ4: Arg4,\n\t\t\t\targ5: Arg5,\n\t\t\t\targ6: Arg6,\n\t\t\t\targ7: Arg7,\n\t\t\t\targ8: Arg8\n\t\t\t) => Promisable<T>\n\t\t>,\n\t\targ1: Promisable<Arg1>,\n\t\targ2: Promisable<Arg2>,\n\t\targ3: Promisable<Arg3>,\n\t\targ4: Promisable<Arg4>,\n\t\targ5: Promisable<Arg5>,\n\t\targ6: Promisable<Arg6>,\n\t\targ7: Promisable<Arg7>,\n\t\targ8: Promisable<Arg8>\n\t): FunPromise<T>;\n\tstatic try<T, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7>(\n\t\tsource: Promisable<\n\t\t\t(\n\t\t\t\targ1: Arg1,\n\t\t\t\targ2: Arg2,\n\t\t\t\targ3: Arg3,\n\t\t\t\targ4: Arg4,\n\t\t\t\targ5: Arg5,\n\t\t\t\targ6: Arg6,\n\t\t\t\targ7: Arg7\n\t\t\t) => Promisable<T>\n\t\t>,\n\t\targ1: Promisable<Arg1>,\n\t\targ2: Promisable<Arg2>,\n\t\targ3: Promisable<Arg3>,\n\t\targ4: Promisable<Arg4>,\n\t\targ5: Promisable<Arg5>,\n\t\targ6: Promisable<Arg6>,\n\t\targ7: Promisable<Arg7>\n\t): FunPromise<T>;\n\tstatic try<T, Arg1, Arg2, Arg3, Arg4, Arg5, Arg6>(\n\t\tsource: Promisable<\n\t\t\t(\n\t\t\t\targ1: Arg1,\n\t\t\t\targ2: Arg2,\n\t\t\t\targ3: Arg3,\n\t\t\t\targ4: Arg4,\n\t\t\t\targ5: Arg5,\n\t\t\t\targ6: Arg6\n\t\t\t) => Promisable<T>\n\t\t>,\n\t\targ1: Promisable<Arg1>,\n\t\targ2: Promisable<Arg2>,\n\t\targ3: Promisable<Arg3>,\n\t\targ4: Promisable<Arg4>,\n\t\targ5: Promisable<Arg5>,\n\t\targ6: Promisable<Arg6>\n\t): FunPromise<T>;\n\tstatic try<T, Arg1, Arg2, Arg3, Arg4, Arg5>(\n\t\tsource: Promisable<\n\t\t\t(\n\t\t\t\targ1: Arg1,\n\t\t\t\targ2: Arg2,\n\t\t\t\targ3: Arg3,\n\t\t\t\targ4: Arg4,\n\t\t\t\targ5: Arg5\n\t\t\t) => Promisable<T>\n\t\t>,\n\t\targ1: Promisable<Arg1>,\n\t\targ2: Promisable<Arg2>,\n\t\targ3: Promisable<Arg3>,\n\t\targ4: Promisable<Arg4>,\n\t\targ5: Promisable<Arg5>\n\t): FunPromise<T>;\n\tstatic try<T, Arg1, Arg2, Arg3, Arg4>(\n\t\tsource: Promisable<\n\t\t\t(arg1: Arg1, arg2: Arg2, arg3: Arg3, arg4: Arg4) => Promisable<T>\n\t\t>,\n\t\targ1: Promisable<Arg1>,\n\t\targ2: Promisable<Arg2>,\n\t\targ3: Promisable<Arg3>,\n\t\targ4: Promisable<Arg4>\n\t): FunPromise<T>;\n\tstatic try<T, Arg1, Arg2, Arg3>(\n\t\tsource: Promisable<(arg1: Arg1, arg2: Arg2, arg3: Arg3) => Promisable<T>>,\n\t\targ1: Promisable<Arg1>,\n\t\targ2: Promisable<Arg2>,\n\t\targ3: Promisable<Arg3>\n\t): FunPromise<T>;\n\tstatic try<T, Arg1, Arg2>(\n\t\tsource: Promisable<(arg1: Arg1, arg2: Arg2) => Promisable<T>>,\n\t\targ1: Promisable<Arg1>,\n\t\targ2: Promisable<Arg2>\n\t): FunPromise<T>;\n\tstatic try<T, Arg1>(\n\t\tsource: Promisable<(arg1: Arg1) => Promisable<T>>,\n\t\targ1: Promisable<Arg1>\n\t): FunPromise<T>;\n\tstatic try<T>(source: Promisable<() => Promisable<T>>): FunPromise<T>;\n\tstatic try<T, ArgT = any>(\n\t\tsource: Promisable<(...args: ArgT[]) => Promisable<T>>,\n\t\t...args: ArgT[]\n\t): FunPromise<T> {\n\t\treturn FunPromise.resolve(source).then((f) => {\n\t\t\tif (_isEmpty(args)) {\n\t\t\t\treturn f();\n\t\t\t} else {\n\t\t\t\treturn Promise.all(args).then((realArgs) => f(...realArgs));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Unwraps layers of `PromiseLike` wrappers as necessary.\n\t *\n\t * This behavior is actually part of the Promise/A+ spec, but the type system struggles with that fact,\n\t * so this method is a workaround.\n\t *\n\t * In a future version of this library, `FunPromise` will extend `Promise<Unpromise<T>>` instead of\n\t * just `Promise<T>`, which will render this method irrelevant. Unfortunately, Typescript's type system\n\t * doesn't seem capable of handling that reality quite yet, so this is what we get.\n\t */\n\tsimplify(): FunPromise<Unpromise<T>> {\n\t\treturn (this as unknown) as FunPromise<Unpromise<T>>;\n\t}\n\n\t/**\n\t * Coerces the resolve value (which must be an `Iterable`) into an array.  The `Iterable` requirement\n\t * comes from the `Item<T>` return value: `Item<T>` is equivalent to `never` if `T` is not an `Iterable`.\n\t *\n\t * Note that this function does *NOT* resolve the items within the array unless you pass the first argument\n\t * as `true`.  The items are not resolved sequentially unless you also pass a second argument as `true`.\n\t */\n\tarrayify(\n\t\tresolveValues: boolean = false,\n\t\tsequentialResolution: boolean = false\n\t): FunPromise<Item<T>[]> {\n\t\tconst aryPromise: FunPromise<Item<T>[]> = this.then((iter) => [\n\t\t\t...((iter as unknown) as Iterable<Item<T>>),\n\t\t]);\n\t\tif (resolveValues) {\n\t\t\tif (sequentialResolution) {\n\t\t\t\treturn aryPromise.then(async (ary) => {\n\t\t\t\t\tconst results = [];\n\t\t\t\t\twhile (!_isEmpty(ary)) {\n\t\t\t\t\t\tresults.push(await ary.shift());\n\t\t\t\t\t}\n\t\t\t\t\treturn results;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn aryPromise.then((ary) => Promise.all(ary));\n\t\t\t}\n\t\t} else {\n\t\t\treturn aryPromise;\n\t\t}\n\t}\n\n\t/**\n\t * Given a mapping function, apply the mapping function to each element of the promise's resolved value,\n\t * and return an array with the results of the mapping.  If any of the mapping results are rejected,\n\t * the entire operation will be rejected.\n\t *\n\t * The order of the elements in the result correspond to the order of the elements in the promise's\n\t * resolved value.  However, the resolution order is not guaranteed.  For example, although the\n\t * output at index 0 will hold the mapping of the input element at index 0, it is not guaranteed that\n\t * the mapping of index 0 will be awaited before the mapping of index 1.\n\t */\n\tmap<T2 = Item<T>>(mapper: (it: Item<T>) => Promisable<T2>): FunPromise<T2[]> {\n\t\tconst results = [];\n\t\treturn FunPromise.try(async () => {\n\t\t\tawait Promise.all(\n\t\t\t\t_map(await this.arrayify(), async (value, idx) => {\n\t\t\t\t\tresults[idx] = await mapper(await value);\n\t\t\t\t})\n\t\t\t);\n\t\t\treturn results;\n\t\t});\n\t}\n\n\t/**\n\t * Equivalent to `FunPromise.resolve(values).map(mapper)`.\n\t */\n\tstatic map<T, T2 = T>(\n\t\tvalues: PromisableIterable<T>,\n\t\tmapper: (it: T) => Promisable<T2>\n\t): FunPromise<T2[]> {\n\t\treturn FunPromise.resolve(values).map(mapper);\n\t}\n\n\t/**\n\t * Required to implement `Promise`, but you almost certainly don't care about it.\n\t *\n\t * All the same, it returns the string tag of the underlying promise.\n\t */\n\tget [Symbol.toStringTag]() {\n\t\treturn this.wrapped[Symbol.toStringTag];\n\t}\n\n\t/**\n\t * Executes the provided code whether the promise rejects or resolves.\n\t */\n\tfinally(): FunPromise<T>;\n\tfinally(onfinally: () => void): FunPromise<T>;\n\tfinally(onfinally?) {\n\t\tif (_isFunction(onfinally)) {\n\t\t\treturn new FunPromise(this.wrapped.finally(onfinally));\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t}\n\n\t/**\n\t * Given a [[`PromisableIterable`]] whose values are nullary functions returning [[Promisable|`Promisable<T>`]],\n\t * this executes all the functions simultaneously and returns the first whose return value passes the provided test.\n\t * The default test returns true if the value is not `null` or `undefined`.\n\t *\n\t * If no function resolves successfully, the last seen rejection is thrown. If some functions resolve but some reject,\n\t * and none of the resolved values pass the test, then the last seen rejection is thrown.\n\t *\n\t * If all the functions resolve but to a value but no value passes the test, then this rejects with an error saying as much.\n\t */\n\tstatic coalesce<T>(\n\t\tfns: PromisableIterable<() => Promisable<T>>,\n\t\ttest: (item: T) => Promisable<boolean> = _negate(_isNil)\n\t): FunPromise<T> {\n\t\tlet resolved = false;\n\t\tlet lastSeenReason = new Error(\"No values left after coalescing\");\n\t\tlet resolveValue;\n\t\treturn FunPromise.map(fns, (fn) =>\n\t\t\tFunPromise.try(fn)\n\t\t\t\t.then((result) => {\n\t\t\t\t\tif (resolved) return null;\n\t\t\t\t\treturn FunPromise.try(test, result).then((testResult) => {\n\t\t\t\t\t\tif (resolved) return null;\n\t\t\t\t\t\tif (testResult) {\n\t\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t\t\tresolveValue = result;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\tlastSeenReason = e;\n\t\t\t\t})\n\t\t).then(() => {\n\t\t\tif (resolved) {\n\t\t\t\treturn resolveValue;\n\t\t\t} else {\n\t\t\t\tthrow lastSeenReason;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Waits for `waitTimeMs` milliseconds before resolving.  If `returnValue` is provided, resolves with the provided value.\n\t *\n\t * If `waitTimeMs` is less than or equal to zero, then it simply defers until the call stack is clear.\n\t */\n\tstatic delay(waitTimeMs: number): FunPromise<void>;\n\tstatic delay<T>(\n\t\twaitTimeMs: number,\n\t\treturnValue: Promisable<T>\n\t): FunPromise<T>;\n\tstatic delay(waitTimeMs, returnValue?) {\n\t\treturn FunPromise.resolve().delay(waitTimeMs, returnValue);\n\t}\n\n\t/**\n\t * Waits for `waitTimeMs` milliseconds before resolving.  If `returnValue` is provided, resolves with the provided value.\n\t *\n\t * If `waitTimeMs` is less than or equal to zero, then it simply defers until the call stack is clear.\n\t */\n\tdelay<T = void>(\n\t\twaitTimeMs: number,\n\t\treturnValue?: Promisable<T>\n\t): FunPromise<T> {\n\t\tif (waitTimeMs <= 0) {\n\t\t\treturn new FunPromise(\n\t\t\t\tnew Promise((resolve) => _defer(resolve, returnValue))\n\t\t\t);\n\t\t} else {\n\t\t\treturn new FunPromise(\n\t\t\t\tnew Promise((resolve) => _delay(resolve, waitTimeMs, returnValue))\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Given a filtering function, apply the filtering function to each element of the promise's resolved value,\n\t * and return an array with the values for which the filtering function returns `true`.  If any of the filtering\n\t * results are rejected, the entire operation will be rejected.\n\t *\n\t * The order of the elements in the result are stable with regard to the order of the elements in the promise's\n\t * resolved value.  That is, if `X < Y` and `input[X]` and `input[Y]` are both in the input, and `input[X]` and\n\t * `input[Y]` both pass the filtering function, then the output index of `input[X]` will be less than the output\n\t * index of `input[Y]`. However, the resolution order is not guaranteed: that is, `input[Y]` may be resolved and\n\t * tested before `input[X]` even though `input[X]` has a lower output index than `input[Y]`.\n\t */\n\tfilter(test: (it: Item<T>) => Promisable<boolean>): FunPromise<Item<T>[]> {\n\t\treturn this.arrayify().then(async (ary) => {\n\t\t\tconst results = await FunPromise.map(ary, async (it) => test(await it));\n\t\t\t// @ts-ignore\n\t\t\treturn _filter(ary, (it, idx) => results[idx]);\n\t\t});\n\t}\n\n\t/**\n\t * Equivalent to `FunPromise.resolve(items).filter(test)`.\n\t */\n\tstatic filter<T>(\n\t\titems: PromisableIterable<T>,\n\t\ttest: (it: Item<PromisableIterable<T>>) => Promisable<boolean>\n\t): FunPromise<Item<PromisableIterable<T>>[]> {\n\t\treturn FunPromise.resolve(items).filter(test);\n\t}\n\n\t/**\n\t * Given a mapping function, apply the mapping function to each element of the promise's resolved value,\n\t * and return an array with the concatenated results of the mapping.  If any of the mapping results are\n\t * rejected, the entire operation will be rejected.\n\t *\n\t * The order of the elements in the result correspond to the order of the elements in the promise's\n\t * resolved value.  However, the resolution order is not guaranteed.\n\t */\n\tflatMap<T2 = Item<T>>(\n\t\tmapper: (it: Item<T>) => Promisable<T2[]>\n\t): FunPromise<T2[]> {\n\t\treturn this.arrayify().then(async (ary: Promisable<Item<T>>[]) => {\n\t\t\tconst promises: Array<Promise<Array<T2>>> = _map(ary, async (value) =>\n\t\t\t\tmapper(await value)\n\t\t\t);\n\t\t\tconst resolved: T2[][] = await Promise.all(promises);\n\t\t\tconst flattened: T2[] = _flatten(resolved);\n\t\t\treturn flattened;\n\t\t});\n\t}\n\n\t/**\n\t * Equivalent to `FunPromise.resolve(values).flatMap(mapper)`.\n\t */\n\tstatic flatMap<T, T2 = T>(\n\t\tvalues: PromisableIterable<T>,\n\t\tmapper: (it: T) => Promisable<T2[]>\n\t): FunPromise<T2[]> {\n\t\treturn FunPromise.resolve(values).flatMap(mapper);\n\t}\n\n\t/**\n\t * Access the resolved value without changing it.  Note that if the callback rejects (ie: throws),\n\t * then the resulting promise will be rejected.\n\t */\n\ttap(callback: (val: T) => Promisable<void>): FunPromise<T> {\n\t\treturn this.then(async (val) => {\n\t\t\tawait callback(val);\n\t\t\treturn val;\n\t\t});\n\t}\n\n\t/**\n\t * Access the rejection reason without changing it.  Note that if the callback itself rejects (ie: throws),\n\t * both rejection reasons will be capture in a single [[`NestedError`]].\n\t */\n\ttapCatch(callback: (reason: unknown) => Promisable<void>): FunPromise<T> {\n\t\treturn this.catch(async (err) => {\n\t\t\ttry {\n\t\t\t\tawait callback(err);\n\t\t\t} catch (err2) {\n\t\t\t\tthrow new NestedError(\"Error thrown in 'tapCatch'\", err, err2);\n\t\t\t}\n\t\t\tthrow err;\n\t\t});\n\t}\n\n\t/**\n\t * Given an initial value and an accumulator function, apply the accumlator function to each element of the promise's resolved value,\n\t * passing in the current value and the result.  Returns an array with the result of the accumulation.  If any of the promise's values are\n\t * rejected, the entire operation will be rejected.\n\t *\n\t * The resolution order is not guaranteed. The accumulator function will be passed values as those values resolve.\n\t */\n\tfold<T2 = Item<T>>(\n\t\tinitialValue: T2,\n\t\taccumulator: (memo: T2, it: Item<T>) => Promisable<T2>\n\t): FunPromise<T2> {\n\t\treturn this.arrayify().then(async (ary: Promisable<Item<T>>[]) => {\n\t\t\tlet memoPromise = FunPromise.resolve(initialValue);\n\t\t\tawait Promise.all(\n\t\t\t\t_map(ary, async (promisableValue) => {\n\t\t\t\t\tconst value = await promisableValue;\n\t\t\t\t\tmemoPromise = memoPromise.then((memo) => accumulator(memo, value));\n\t\t\t\t})\n\t\t\t);\n\t\t\treturn await memoPromise;\n\t\t});\n\t}\n\n\t/**\n\t * Equivalent to `FunPromise.resolve(values).fold(initialValue, accumulator)`.\n\t */\n\tstatic fold<T, T2 = T>(\n\t\tvalues: PromisableIterable<T>,\n\t\tinitialValue: T2,\n\t\taccumulator: (memo: T2, it: T) => Promisable<T2>\n\t): FunPromise<T2> {\n\t\treturn FunPromise.resolve(values).fold(initialValue, accumulator);\n\t}\n}\n"]}