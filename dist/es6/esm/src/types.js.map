{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../../src/types.ts"],"names":[],"mappings":"AAAA;;;;;;;GAOG;AAuDH;;GAEG;AACH,MAAM,CAAN,IAAY,YA+BX;AA/BD,WAAY,YAAY;IACvB;;OAEG;IACH,mCAAmB,CAAA;IAEnB;;OAEG;IACH,uCAAuB,CAAA;IAEvB;;OAEG;IACH,qCAAqB,CAAA;IAErB;;OAEG;IACH,uCAAuB,CAAA;IAEvB;;OAEG;IACH,qCAAqB,CAAA;IAErB;;;OAGG;IACH,uCAAuB,CAAA;AACxB,CAAC,EA/BW,YAAY,KAAZ,YAAY,QA+BvB","sourcesContent":["/**\n * @format\n *\n * These are where we put all the type aliases, interfaces, and enumerations that are shared\n * between multiple things, or may be useful to use without us.\n *\n * @packageDocumentation\n */\n\n/**\n * Provides the type of elements within an `Iterable`, which may be wrapped in one or more promises.\n * The element type is also unwrapped any promises.\n */\nexport type Item<T> = Unpromise<T> extends Array<infer U>\n\t? U\n\t: Unpromise<T> extends Iterable<infer U>\n\t? U\n\t: never;\n\n/**\n * Provides the type of the resolution value after unwrapping all the `PromiseLike` and [[`Promisable`]] interfaces (if any).\n */\nexport type Unpromise<T> = T extends PromiseLike<infer U>\n\t? Unpromise<U>\n\t: T extends Promisable<infer U>\n\t? U extends T\n\t\t? T\n\t\t: Unpromise<U>\n\t: T;\n\n/**\n * Something which can be resolved: that is, either a value or a promise of a value.\n */\nexport type Promisable<T> = T | PromiseLike<T>;\n\n/**\n * Guarantees that there is only one `Promise` wrapper.\n */\nexport type SimplifiedPromise<T> = Promise<Unpromise<T>>;\n\n/**\n * Guarantees that there is only one `PromiseLike` wrapper.\n */\nexport type SimplifiedPromiseLike<T> = PromiseLike<Unpromise<T>>;\n\n/**\n * Guarantees that there is at most one `PromiseLike` wrapper.\n */\nexport type SimplifiedPromisable<T> = Promisable<Unpromise<T>>;\n\n/**\n * An `Iterable` or a promise of an `Iterable`. Its elements are any mix of type `T` and/or `PromiseLike<T>`.\n * Used as a type for arguments.\n */\nexport type PromisableIterable<T> = Promisable<IterableOfPromisables<T>>;\n\n/**\n * Represents an `Iterable` that is not a promise but an actual value that is an `Iterable`,\n * although it may produce either values or promises of values or both.\n */\nexport type IterableOfPromisables<T> = Iterable<Promisable<T>>;\n\n/**\n * The various states that a promise can be in.\n */\nexport enum PromiseState {\n\t/**\n\t * The promise is neither resolved nor rejected.\n\t */\n\tPending = \"pending\",\n\n\t/**\n\t * The promise has begun resolving, but is not yet fully resolved.\n\t */\n\tResolving = \"resolving\",\n\n\t/**\n\t * The promise has resolved to a value.\n\t */\n\tResolved = \"resolved\",\n\n\t/**\n\t * The promise has begun rejecting, but is not yet fully rejected.\n\t */\n\tRejecting = \"rejecting\",\n\n\t/**\n\t * The promise has rejected with a cause.\n\t */\n\tRejected = \"rejected\",\n\n\t/**\n\t * The promise has been cancelled, which will prevent its\n\t * callbacks from firing.\n\t */\n\tCancelled = \"cancelled\",\n}\n"]}