"use strict";var _interopRequireDefault=require("@babel/runtime-corejs3/helpers/interopRequireDefault");let _Symbol$toStringTag;exports.__esModule=!0,exports.default=exports.Deferral=exports.PromiseState=void 0;var _filter2=_interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter")),_map2=_interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map")),_promise=_interopRequireDefault(require("@babel/runtime-corejs3/core-js/promise")),_toStringTag=_interopRequireDefault(require("@babel/runtime-corejs3/core-js/symbol/to-string-tag")),_toString2=_interopRequireDefault(require("lodash/toString")),_filter3=_interopRequireDefault(require("lodash/filter")),_map3=_interopRequireDefault(require("lodash/map")),_isFunction2=_interopRequireDefault(require("lodash/isFunction")),_isEmpty2=_interopRequireDefault(require("lodash/isEmpty")),_isNil2=_interopRequireDefault(require("lodash/isNil")),_pull2=_interopRequireDefault(require("lodash/pull")),_forEach2=_interopRequireDefault(require("lodash/forEach")),_once2=_interopRequireDefault(require("lodash/once")),_identity2=_interopRequireDefault(require("lodash/identity")),_toArray2=_interopRequireDefault(require("lodash/toArray")),_castArray2=_interopRequireDefault(require("lodash/castArray")),_clone2=_interopRequireDefault(require("lodash/clone")),_defer2=_interopRequireDefault(require("lodash/defer")),_isError2=_interopRequireDefault(require("lodash/isError"));function isError(a){return(0,_isError2.default)(a)}var PromiseState;exports.PromiseState=PromiseState,function(a){a.Pending="pending",a.Resolving="resolving",a.Resolved="resolved",a.Rejecting="rejecting",a.Rejected="rejected"}(PromiseState||(exports.PromiseState=PromiseState={}));class Deferral{get state(){return this.stateValue}get isSettling(){switch(this.stateValue){case PromiseState.Resolving:return!0;case PromiseState.Rejecting:return!0;default:return!1;}}get isResolved(){return this.stateValue===PromiseState.Resolved}get isRejected(){return this.stateValue===PromiseState.Rejected}resolve(a){const{resolver:b}=this;if(b)try{const{rejector:c}=this;this.stateValue=PromiseState.Resolving,(0,_defer2.default)(()=>{try{b(a),this.stateValue=PromiseState.Resolved}catch(a){c?(this.rejector=c,this.reject(a)):console.warn(`Uncaught exception during resolution`,a)}})}catch(a){this.reject(a)}finally{this.resolver=null,this.rejector=null}return this.promise}reject(a){const{rejector:b}=this;if(b)try{this.stateValue=PromiseState.Rejecting,(0,_defer2.default)(()=>{try{b(a)}finally{this.stateValue=PromiseState.Rejected}})}finally{this.resolver=null,this.rejector=null}return this.promise}constructor(){this.promise=void 0,this.stateValue=PromiseState.Pending,this.resolver=null,this.rejector=null,this.promise=FunPromise.new((a,b)=>{this.resolver=a,this.rejector=b})}}exports.Deferral=Deferral,_Symbol$toStringTag=_toStringTag.default;class FunPromise{constructor(a){this.wrapped=void 0,this[_Symbol$toStringTag]=void 0,this.wrapped=a,this[_toStringTag.default]=a[_toStringTag.default]}static wrap(a){return a instanceof FunPromise?a:a instanceof _promise.default?new FunPromise(a):new FunPromise(new _promise.default(b=>b(a)))}static resolve(a){return a instanceof _promise.default||a instanceof FunPromise?FunPromise.wrap(a):FunPromise.new(b=>b(a))}static new(a){return FunPromise.wrap(new _promise.default(a))}processArray(a){return FunPromise.wrap(this.arrayify().wrapped.then(async b=>{const c=(0,_clone2.default)((0,_castArray2.default)(b)),d=a(c);return _promise.default.all((0,_toArray2.default)(d))}))}reduceArray(a){const b=this.arrayify().wrapped.then(a);return FunPromise.wrap(b)}static try(a){return FunPromise.new(b=>b(a()))}static all(a){return FunPromise.resolve(a).all()}all(){return this.processArray(_identity2.default)}static race(a,b){return FunPromise.resolve(a).race(b)}race(a){return this.reduceArray(b=>new _promise.default(async(c,d)=>{const e=(0,_once2.default)(c);(0,_forEach2.default)(b,c=>FunPromise.resolve(c).tapFinally(()=>{(0,_pull2.default)(b,c)}).then(e,c=>{(0,_isNil2.default)(a)||a(c),(0,_isEmpty2.default)(b)&&d(c)}))}))}static coalesce(a){return FunPromise.resolve(a).coalesce()}coalesce(){return this.reduceArray(async a=>{var b;let c=null;for(;!(0,_isEmpty2.default)(a);)try{const b=a.shift();if((0,_isFunction2.default)(b))return await b()}catch(a){c=a}throw null==(b=c)?new Error("No values found to coalesce"):b})}static map(a,b){var c;return(0,_map2.default)(c=FunPromise.resolve(a)).call(c,b)}map(a){return this.reduceArray(b=>_promise.default.all((0,_map3.default)(b,a)))}static mapSeq(a,b){var c;return(0,_map2.default)(c=FunPromise.resolve(a)).call(c,b)}mapSeq(a){return this.reduceArray(async b=>{const c=[];for(c.length=b.length;!(0,_isEmpty2.default)(b);)c.push(a(await b.shift()));return c})}static fold(a,b,c){return FunPromise.resolve(a).fold(b,c)}fold(a,b){return this.reduceArray(c=>{let d=FunPromise.resolve(a);return _promise.default.all((0,_map3.default)(c,async a=>{const c=await a;d=d.then(a=>b(a,c))})).then(async()=>await d)})}static foldSeq(a,b,c){return FunPromise.resolve(a).fold(b,c)}foldSeq(a,b){return this.reduceArray(c=>{let d=FunPromise.resolve(a);for(;!(0,_isEmpty2.default)(c);){const a=c.shift();d=d.then(async c=>b(c,await a))}return d})}static filter(a,b){var c;return(0,_filter2.default)(c=FunPromise.resolve(a)).call(c,b)}filter(a){return this.processArray(async b=>{const c=await _promise.default.all((0,_map3.default)(b,a));return(0,_filter3.default)(b,(a,b)=>(a,c[b]))})}static filterSeq(a,b){return FunPromise.resolve(a).filterSeq(b)}filterSeq(a){return this.processArray(async b=>{const c=[];for(;!(0,_isEmpty2.default)(b);){const d=b.shift();(await a(d))&&c.push(d)}return c})}then(a,b){return FunPromise.wrap(this.wrapped.then(a,b))}catch(a){return FunPromise.wrap(this.wrapped.catch(a))}finally(a){return FunPromise.wrap(this.wrapped.finally(a))}catchError(a){return this.catch(b=>{if((0,_isNil2.default)(b))throw new Error(`Promise was rejected without a reason`);else isError(b)?a(b):a(new Error(`Promise was rejected; expected Error, but saw: ${(0,_toString2.default)(b)} (${typeof b})`))})}tap(a){return this.then(async b=>(await a(b),b))}tapCatch(a){return this.catchError(b=>FunPromise.try(()=>a(b)).finally(()=>{throw b}))}tapFinally(a,b){return this.tap(a).tapCatch(null==b?a:b)}return(a){return FunPromise.wrap(this.wrapped.then(()=>a))}arrayify(){return FunPromise.wrap(this.wrapped.then(a=>(0,_toArray2.default)(a)))}simplify(){return this}result(){return this.catchError(_identity2.default)}}exports.default=FunPromise;