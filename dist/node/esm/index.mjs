import _filterInstanceProperty from"@babel/runtime-corejs3/core-js/instance/filter";import _mapInstanceProperty from"@babel/runtime-corejs3/core-js/instance/map";import _Promise from"@babel/runtime-corejs3/core-js/promise";import _Symbol$toStringTag2 from"@babel/runtime-corejs3/core-js/symbol/to-string-tag";import _toString from"lodash/toString";import _filter from"lodash/filter";import _map from"lodash/map";import _isFunction from"lodash/isFunction";import _isEmpty from"lodash/isEmpty";import _isNil from"lodash/isNil";import _pull from"lodash/pull";import _forEach from"lodash/forEach";import _once from"lodash/once";import _identity from"lodash/identity";import _toArray from"lodash/toArray";import _castArray from"lodash/castArray";import _clone from"lodash/clone";import _defer from"lodash/defer";import _isError from"lodash/isError";let _Symbol$toStringTag;function isError(it){return _isError(it)}export var PromiseState;(function(PromiseState){PromiseState["Pending"]="pending";PromiseState["Resolving"]="resolving";PromiseState["Resolved"]="resolved";PromiseState["Rejecting"]="rejecting";PromiseState["Rejected"]="rejected"})(PromiseState||(PromiseState={}));export class Deferral{get state(){return this.stateValue}get isSettling(){switch(this.stateValue){case PromiseState.Resolving:return true;case PromiseState.Rejecting:return true;default:return false;}}get isResolved(){return this.stateValue===PromiseState.Resolved}get isRejected(){return this.stateValue===PromiseState.Rejected}resolve(it){const{resolver}=this;if(resolver){try{const{rejector}=this;this.stateValue=PromiseState.Resolving;_defer(()=>{try{resolver(it);this.stateValue=PromiseState.Resolved}catch(e){if(rejector){this.rejector=rejector;this.reject(e)}else{console.warn(`Uncaught exception during resolution`,e)}}})}catch(e){this.reject(e)}finally{this.resolver=null;this.rejector=null}}return this.promise}reject(e){const{rejector}=this;if(rejector){try{this.stateValue=PromiseState.Rejecting;_defer(()=>{try{rejector(e)}finally{this.stateValue=PromiseState.Rejected}})}finally{this.resolver=null;this.rejector=null}}return this.promise}constructor(){this.promise=void 0;this.stateValue=PromiseState.Pending;this.resolver=null;this.rejector=null;this.promise=FunPromise.new((resolve,reject)=>{this.resolver=resolve;this.rejector=reject})}}_Symbol$toStringTag=_Symbol$toStringTag2;export default class FunPromise{constructor(wrapped){this.wrapped=void 0;this[_Symbol$toStringTag]=void 0;this.wrapped=wrapped;this[_Symbol$toStringTag2]=wrapped[_Symbol$toStringTag2]}static wrap(promise){if(promise instanceof FunPromise){return promise}else if(promise instanceof _Promise){return new FunPromise(promise)}else{return new FunPromise(new _Promise(resolve=>resolve(promise)))}}static resolve(it){if(it instanceof _Promise||it instanceof FunPromise){return FunPromise.wrap(it)}else{return FunPromise.new(resolver=>resolver(it))}}static new(executor){return FunPromise.wrap(new _Promise(executor))}processArray(handler){return FunPromise.wrap(this.arrayify().wrapped.then(async inputIterable=>{const ary=_clone(_castArray(inputIterable));const resultIterable=handler(ary);return _Promise.all(_toArray(resultIterable))}))}reduceArray(handler){const toWrap=this.arrayify().wrapped.then(handler);return FunPromise.wrap(toWrap)}static try(fn){return FunPromise.new(resolver=>resolver(fn()))}static all(them){return FunPromise.resolve(them).all()}all(){return this.processArray(_identity)}static race(them,errorHandler){return FunPromise.resolve(them).race(errorHandler)}race(errorHandler){return this.reduceArray(ary=>new _Promise(async(resolver,rejector)=>{const doResolve=_once(resolver);_forEach(ary,it=>FunPromise.resolve(it).tapFinally(()=>{_pull(ary,it)}).then(doResolve,e=>{if(!_isNil(errorHandler))errorHandler(e);if(_isEmpty(ary))rejector(e)}))}))}static coalesce(them){return FunPromise.resolve(them).coalesce()}coalesce(){return this.reduceArray(async ary=>{var _lastRejection;let lastRejection=null;while(!_isEmpty(ary)){try{const factory=ary.shift();if(_isFunction(factory)){return await factory()}}catch(e){lastRejection=e}}throw(_lastRejection=lastRejection)!=null?_lastRejection:new Error("No values found to coalesce")})}static map(them,mapper){var _context;return _mapInstanceProperty(_context=FunPromise.resolve(them)).call(_context,mapper)}map(mapper){return this.reduceArray(ary=>_Promise.all(_map(ary,mapper)))}static mapSeq(them,mapper){var _context2;return _mapInstanceProperty(_context2=FunPromise.resolve(them)).call(_context2,mapper)}mapSeq(mapper){return this.reduceArray(async ary=>{const result=[];result.length=ary.length;while(!_isEmpty(ary)){result.push(mapper(await ary.shift()))}return result})}static fold(them,initialValue,handler){return FunPromise.resolve(them).fold(initialValue,handler)}fold(initialValue,handler){return this.reduceArray(ary=>{let memo=FunPromise.resolve(initialValue);return _Promise.all(_map(ary,async it=>{const result=await it;memo=memo.then(newMemo=>handler(newMemo,result))})).then(async()=>await memo)})}static foldSeq(them,initialValue,handler){return FunPromise.resolve(them).fold(initialValue,handler)}foldSeq(initialValue,handler){return this.reduceArray(ary=>{let memoPromise=FunPromise.resolve(initialValue);while(!_isEmpty(ary)){const nextPromise=ary.shift();memoPromise=memoPromise.then(async memo=>handler(memo,await nextPromise))}return memoPromise})}static filter(them,filter){var _context3;return _filterInstanceProperty(_context3=FunPromise.resolve(them)).call(_context3,filter)}filter(test){return this.processArray(async ary=>{const testResults=await _Promise.all(_map(ary,test));return _filter(ary,(item,idx)=>{item;return testResults[idx]})})}static filterSeq(them,filter){return FunPromise.resolve(them).filterSeq(filter)}filterSeq(test){return this.processArray(async ary=>{const result=[];while(!_isEmpty(ary)){const it=ary.shift();if(await test(it))result.push(it)}return result})}then(onfulfilled,onrejected){return FunPromise.wrap(this.wrapped.then(onfulfilled,onrejected))}catch(handler){return FunPromise.wrap(this.wrapped.catch(handler))}finally(handler){return FunPromise.wrap(this.wrapped.finally(handler))}catchError(handler=_identity){return this.catch(reason=>{if(_isNil(reason)){throw new Error(`Promise was rejected without a reason`)}else if(isError(reason)){handler(reason)}else{handler(new Error(`Promise was rejected; expected Error, but saw: ${_toString(reason)} (${typeof reason})`))}})}tap(handler){return this.then(async result=>{await handler(result);return result})}tapCatch(handler){return this.catchError(e=>FunPromise.try(()=>handler(e)).finally(()=>{throw e}))}tapFinally(handler,errHandler){return this.tap(handler).tapCatch(errHandler!=null?errHandler:handler)}return(value){return FunPromise.wrap(this.wrapped.then(()=>value))}arrayify(){return FunPromise.wrap(this.wrapped.then(iterable=>_toArray(iterable)))}simplify(){return this}}