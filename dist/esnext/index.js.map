{"version":3,"file":"index.js","sourceRoot":"","sources":["../../index.ts"],"names":[],"mappings":"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","sourcesContent":["/** @format */\n\nimport _ from \"lodash\";\n\n/**\n * No type guard on this in Lodash's typing?\n */\nfunction isError(it: unknown): it is Error {\n\treturn _.isError(it);\n}\n\n/**\n * Provides the type of elements within an [[`Iterable`]], which may be wrapped in one or more promises.\n * The element type is also unwrapped any promises.\n */\nexport type Element<T> = Unpromise<T> extends Iterable<infer U>\n\t? Unpromise<U>\n\t: never;\n\n/**\n * Provides the type of the resolution value after unwrapping all the [[`PromiseLike`]] and [[`Promisable`]] interfaces (if any).\n */\nexport type Unpromise<T> = T extends PromiseLike<infer U>\n\t? Unpromise<U>\n\t: T extends Promisable<infer U>\n\t? U extends T\n\t\t? T\n\t\t: Unpromise<U>\n\t: T;\n\n/**\n * Something which can be resolved: that is, either a value or a promise of a value.\n */\nexport type Promisable<T> = T | PromiseLike<T>;\n\n/**\n * Guarantees that there is at most one [[`Promise`]] wrapper.\n */\nexport type SimplifiedPromise<T> = Promise<Unpromise<T>>;\n\n/**\n * Guarantees that there is at most one [[`Promisable`]] wrapper.\n */\nexport type SimplifiedPromisable<T> = Promisable<Unpromise<T>>;\n\n/**\n * An [[`Iterable`]] or a promise of an `Iterable`. Its elements are any mix of type `T` and/or `PromiseLike<T>`.\n * Used as a type for arguments.\n */\nexport type PromisableIterable<T> = Promisable<Iterable<Promisable<T>>>;\n\n/**\n * Represents an `Iterable` that is not a promise but an actual value that is an `Iterable`,\n * although it may produce either values or promises of values or both.\n */\nexport type IterableOfPromisables<T> = Iterable<Promisable<T>>;\n\n/**\n * The various states that a promise can be in.\n */\nexport enum PromiseState {\n\t/**\n\t * The promise is neither resolved nor rejected.\n\t */\n\tPending = \"pending\",\n\n\t/**\n\t * The promise has begun resolving, but is not yet fully resolved.\n\t */\n\tResolving = \"resolving\",\n\n\t/**\n\t * The promise has resolved to a value.\n\t */\n\tResolved = \"resolved\",\n\n\t/**\n\t * The promise has begun rejecting, but is not yet fully rejected.\n\t */\n\tRejecting = \"rejecting\",\n\n\t/**\n\t * The promise has rejected with a cause.\n\t */\n\tRejected = \"rejected\",\n}\n\n/**\n * A class that is an \"inside-out\" [[`FunPromise`]]: the `resolve` and `reject` functions\n * from the callback are exposed as properties, and are therefore able to be called by\n * caller's code.\n *\n * Note that after the first call to either `resolve` or `reject`, the underlying promise\n * is settled. Any subsequent call to either `resolve` or `reject` is guaranteed to be\n * a no-op.\n */\nexport class Deferral<T> {\n\t/**\n\t * The promise whose state is determined by `resolve` and `reject`.\n\t */\n\treadonly promise: FunPromise<T>;\n\n\t/**\n\t * The state of `promise`.\n\t */\n\tprivate stateValue: PromiseState = PromiseState.Pending;\n\n\t/**\n\t * The function used to resolve [[`promise`]].\n\t */\n\tprivate resolver: (it: Promisable<T>) => Promisable<void> | null = null;\n\n\t/**\n\t * The function used to reject [[`promise`]].\n\t */\n\tprivate rejector: (err: unknown) => Promisable<void> | null = null;\n\n\t/**\n\t * Provides the state of `promise`.\n\t */\n\tget state() {\n\t\treturn this.stateValue;\n\t}\n\n\t/**\n\t * Whether `promise` is in the process of resolving or rejecting.\n\t */\n\tget isSettling() {\n\t\tswitch (this.stateValue) {\n\t\t\tcase PromiseState.Resolving:\n\t\t\t\treturn true;\n\t\t\tcase PromiseState.Rejecting:\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Whether `promise` has resolved.\n\t */\n\tget isResolved() {\n\t\treturn this.stateValue === PromiseState.Resolved;\n\t}\n\n\t/**\n\t * Whether `promise` was rejected.\n\t */\n\tget isRejected() {\n\t\treturn this.stateValue === PromiseState.Rejected;\n\t}\n\n\t/**\n\t * Resolves `promise` with the given value.\n\t */\n\tresolve(it) {\n\t\tconst { resolver } = this;\n\t\tif (resolver) {\n\t\t\ttry {\n\t\t\t\tconst { rejector } = this;\n\t\t\t\tthis.stateValue = PromiseState.Resolving;\n\t\t\t\t_.defer(() => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolver(it);\n\t\t\t\t\t\tthis.stateValue = PromiseState.Resolved;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tif (rejector) {\n\t\t\t\t\t\t\tthis.rejector = rejector;\n\t\t\t\t\t\t\tthis.reject(e);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.warn(`Uncaught exception during resolution`, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch (e) {\n\t\t\t\tthis.reject(e);\n\t\t\t} finally {\n\t\t\t\tthis.resolver = null;\n\t\t\t\tthis.rejector = null;\n\t\t\t}\n\t\t}\n\t\treturn this.promise;\n\t}\n\n\t/**\n\t * Rejects `promise` with the given cause.\n\t */\n\treject(e: Error) {\n\t\tconst { rejector } = this;\n\t\tif (rejector) {\n\t\t\ttry {\n\t\t\t\tthis.stateValue = PromiseState.Rejecting;\n\t\t\t\t_.defer(() => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trejector(e);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tthis.stateValue = PromiseState.Rejected;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} finally {\n\t\t\t\tthis.resolver = null;\n\t\t\t\tthis.rejector = null;\n\t\t\t}\n\t\t}\n\t\treturn this.promise;\n\t}\n\n\t/**\n\t * Constructs a new promise and exposes its resolve\n\t * and reject functions.\n\t */\n\tconstructor() {\n\t\tthis.promise = FunPromise.new((resolve, reject) => {\n\t\t\tthis.resolver = resolve;\n\t\t\tthis.rejector = reject;\n\t\t});\n\t}\n}\n\n/**\n * The class that you should use instead of [[`Promise`]].  It implements the `Promise` API, so it should be a drop-in replacement.\n */\nexport default class FunPromise<T> implements SimplifiedPromise<T> {\n\t/**\n\t * Classic `[Symbol.toStringTag]` for compliance with [[`Promise<T>`]].\n\t */\n\treadonly [Symbol.toStringTag];\n\n\t/**\n\t * Constructor, which takes as an argument the promise to wrap.  See [[`FunPromise.new`]],\n\t * [[`FunPromise.wrap`]], and [[`FunPromise.resolve`]] for the public ways to construct\n\t * a `FunPromise`.\n\t *\n\t * This constructor is likely to change in the future, although any breaking change will\n\t * cause a major version bump.\n\t */\n\tprotected constructor(protected readonly wrapped: Promise<T>) {\n\t\tthis[Symbol.toStringTag] = wrapped[Symbol.toStringTag];\n\t}\n\n\t/**\n\t * Wraps an existing [[`Promise`]] or [[`PromiseLike`]]. It's a noop if you\n\t * pass in a `FunPromise`.\n\t */\n\tstatic wrap<T>(\n\t\tpromise: FunPromise<T> | Promise<T> | PromiseLike<T>\n\t): FunPromise<T> {\n\t\tif (promise instanceof FunPromise) {\n\t\t\treturn promise;\n\t\t} else if (promise instanceof Promise) {\n\t\t\treturn new FunPromise(promise);\n\t\t} else {\n\t\t\treturn new FunPromise(new Promise((resolve) => resolve(promise)));\n\t\t}\n\t}\n\n\t/**\n\t * Creates a `FunPromise` which resolves to the value of the argument, resolving the\n\t * value if it is a [[`PromiseLike`]].\n\t */\n\tstatic resolve<T>(it: Promisable<T>): FunPromise<T> {\n\t\tif (it instanceof Promise || it instanceof FunPromise) {\n\t\t\treturn FunPromise.wrap(it);\n\t\t} else {\n\t\t\treturn FunPromise.new((resolver) => resolver(it));\n\t\t}\n\t}\n\n\t/**\n\t * Constructor-like factory function that delegates directly to the [[`Promise`]] constructor.  See\n\t * [the MDN documentation on the `Promise` constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise)\n\t * for more information.\n\t */\n\tstatic new<T>(executor): FunPromise<T> {\n\t\treturn FunPromise.wrap(new Promise(executor));\n\t}\n\n\t/**\n\t * Processes the resolved value of this promise as an array, returning an array result.  If the resolved value of this\n\t * promise is not an array, then it is coerced into an array using\n\t * [`_.castArray` from Lodash](https://lodash.com/docs/4.17.15#castArray).\n\t */\n\tprotected processArray<U = Element<T>>(\n\t\thandler: (values: Element<T>[]) => PromisableIterable<U>\n\t): FunPromise<U[]> {\n\t\treturn FunPromise.wrap(\n\t\t\tthis.arrayify().wrapped.then(async (inputIterable) => {\n\t\t\t\tconst ary: Element<T>[] = _.clone(_.castArray(inputIterable));\n\t\t\t\tconst resultIterable = handler(ary);\n\t\t\t\treturn Promise.all(_.toArray(resultIterable));\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Processes the resolved value of this promise as an array, returning a single value as a result.\n\t * If the resolved value of this promise is not an array, then it is coerced into an array using\n\t * [`_.castArray` from Lodash](https://lodash.com/docs/4.17.15#castArray).\n\t */\n\tprotected reduceArray<U = Element<T>>(\n\t\thandler: (values: Element<T>[]) => Promisable<U>\n\t): FunPromise<U> {\n\t\tconst toWrap = this.arrayify().wrapped.then(handler);\n\t\treturn FunPromise.wrap(toWrap);\n\t}\n\n\t/**\n\t * Executes the provided function in a [[`FunPromise`]]. Useful to avoid [releasing Zalgo](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n\t * when the means of creating the promise might explode.\n\t */\n\tstatic try<T>(fn: () => Promisable<T>): FunPromise<T> {\n\t\treturn FunPromise.new((resolver) => resolver(fn()));\n\t}\n\n\t/**\n\t * Classic [[`Promise.all`]], but returning a [[`FunPromise`]].\n\t */\n\tstatic all<T>(them: PromisableIterable<T>) {\n\t\treturn FunPromise.resolve(them).all();\n\t}\n\n\t/**\n\t * `this.all()` is the same as [[ FunPromise.all | `FunPromise.all(this)` ]].  If the payload\n\t * is not an array, then it is coerced into an array using\n\t * [`_.castArray` from Lodash](https://lodash.com/docs/4.17.15#castArray).\n\t */\n\tall() {\n\t\treturn this.processArray(_.identity);\n\t}\n\n\t/**\n\t * Resolves to the first promise to resolve in the [[`PromisableIterable`]] argument.  If all\n\t * the promises in the argument reject, then this rejects with the cause of the final\n\t * rejection encountered.\n\t *\n\t * Note that after the first promise resolves, the other promises are left executing but\n\t * the results of their executions are dropped.\n\t *\n\t * The second argument allows you to handle all the rejections that may be received\n\t * (whether before or after the first resolution).\n\t *\n\t * This builds off [[ ``FunPromise.processArray` ]].\n\t */\n\tstatic race<T>(\n\t\tthem: PromisableIterable<T>,\n\t\terrorHandler?: (e: unknown) => void\n\t) {\n\t\treturn FunPromise.resolve(them).race(errorHandler);\n\t}\n\n\t/**\n\t * `this.race(errorHandler?)` is the same as [[ FunPromise.race | `FunPromise.race(this, errorHandler?)` ]].\n\t */\n\trace(errorHandler?: (e: unknown) => void): FunPromise<Element<T>> {\n\t\treturn this.reduceArray(\n\t\t\t(ary) =>\n\t\t\t\tnew Promise(async (resolver, rejector) => {\n\t\t\t\t\tconst doResolve = _.once(resolver);\n\t\t\t\t\t_.forEach(ary, (it) =>\n\t\t\t\t\t\tFunPromise.resolve(it)\n\t\t\t\t\t\t\t.tapFinally(() => {\n\t\t\t\t\t\t\t\t_.pull(ary, it);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.then(doResolve, (e) => {\n\t\t\t\t\t\t\t\tif (!_.isNil(errorHandler)) errorHandler(e);\n\t\t\t\t\t\t\t\tif (_.isEmpty(ary)) rejector(e);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Given a [[`PromisableIterable`]] whose resolved elements are nullary functions,\n\t * this executes the functions in order until one resolves to a non-[nil|https://lodash.com/docs/4.17.15#isNil]\n\t * value.  If they all reject, then this rejects with the last rejection. If the\n\t * collection is empty, it rejects with an [[`Error`]] stating so.\n\t *\n\t * If the payload is not an array, then it is coerced into an array using\n\t * [`_.castArray` from Lodash](https://lodash.com/docs/4.17.15#castArray).\n\t */\n\tstatic coalesce<T>(them: PromisableIterable<() => Promisable<T>>) {\n\t\treturn FunPromise.resolve(them).coalesce();\n\t}\n\n\t/**\n\t * `this.coalesce()` is the same as [[ FunPromise.coalesce | `FunPromise.coalesce(this)` ]].\n\t */\n\tcoalesce() {\n\t\treturn this.reduceArray(async (ary) => {\n\t\t\tlet lastRejection = null;\n\t\t\twhile (!_.isEmpty(ary)) {\n\t\t\t\ttry {\n\t\t\t\t\tconst factory = ary.shift();\n\t\t\t\t\tif (_.isFunction(factory)) {\n\t\t\t\t\t\treturn await factory();\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tlastRejection = e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow lastRejection ?? new Error(\"No values found to coalesce\");\n\t\t});\n\t}\n\n\t/**\n\t * Given a [[`PromisableIterable`]], resolves each value provided and passes each value through the\n\t * `mapper` function, collecting the results.\n\t *\n\t * The order of input elements is maintained, but the\n\t * resolution order is not -- that is, while the element at index 0 might not resolve until after the\n\t * element at index 1, the input at index 0 is guaranteed to be mapped to the output at index 0.\n\t *\n\t * If the payload is not an array, then it is coerced into an array using\n\t * [`_.castArray` from Lodash](https://lodash.com/docs/4.17.15#castArray).\n\t */\n\tstatic map<T>(them: PromisableIterable<T>, mapper) {\n\t\treturn FunPromise.resolve(them).map(mapper);\n\t}\n\n\t/**\n\t * `this.map(mapper)` is the same as [[ FunPromise.map | `FunPromise.map(this, mapper)` ]].\n\t */\n\tmap<U = Element<T>>(\n\t\tmapper: (it: Element<T>) => Promisable<U>\n\t): FunPromise<U[]> {\n\t\treturn this.reduceArray((ary) => Promise.all(_.map(ary, mapper)));\n\t}\n\n\t/**\n\t * Given a [[`PromisableIterable`]], resolves each value provided and passes each value through the\n\t * `mapper` function, collecting the results.\n\t *\n\t * The order of input elements is maintained, as is the resolution order -- that is, the element at\n\t * index 1 will wait to be resolved by this method until until after the\n\t * element at index 0.\n\t *\n\t * If the payload is not an array, then it is coerced into an array using\n\t * [`_.castArray` from Lodash](https://lodash.com/docs/4.17.15#castArray).\n\t */\n\tstatic mapSeq<T>(them: PromisableIterable<T>, mapper) {\n\t\treturn FunPromise.resolve(them).map(mapper);\n\t}\n\n\t/**\n\t * `this.mapSeq(mapper)` is the same as [[ FunPromise.mapSeq | `FunPromise.mapSeq(this, mapper)` ]].\n\t */\n\tmapSeq<U = Element<T>>(\n\t\tmapper: (it: Element<T>) => Promisable<U>\n\t): FunPromise<U[]> {\n\t\treturn this.reduceArray(async (ary) => {\n\t\t\tconst result = [];\n\t\t\tresult.length = ary.length;\n\t\t\twhile (!_.isEmpty(ary)) {\n\t\t\t\tresult.push(mapper(await ary.shift()));\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\t/**\n\t * Given a [[`PromisableIterable`]] and an initial value, `fold` resolves each value provided and passes\n\t * each value through the `handler` function along with the current state of the `memo`.  The return from\n\t * `handler` becomes the `memo` input of the next round. When there are no more elements, returns the\n\t * final `memo` that was returned.\n\t *\n\t * This implementation does not guarantee any particular order for the inputs to be processed through 'handler':\n\t * the results of the promise values are processed as soon as they are resolved.\n\t *\n\t * If the payload is not an array, then it is coerced into an array using\n\t * [`_.castArray` from Lodash](https://lodash.com/docs/4.17.15#castArray).\n\t */\n\tstatic fold<T, MEMO = Element<T>>(\n\t\tthem: PromisableIterable<T>,\n\t\tinitialValue: Promisable<MEMO>,\n\t\thandler\n\t): FunPromise<MEMO> {\n\t\treturn FunPromise.resolve(them).fold(initialValue, handler);\n\t}\n\n\t/**\n\t * `this.fold(initialValue, handler)` is the same as [[ FunPromise.fold | `FunPromise.fold(this, initialValue, handler)` ]].\n\t */\n\tfold<MEMO = Element<T>>(\n\t\tinitialValue: Promisable<MEMO>,\n\t\thandler: (memo: MEMO, nextItem: Element<T>) => Promisable<MEMO>\n\t): FunPromise<MEMO> {\n\t\treturn this.reduceArray((ary) => {\n\t\t\tlet memo: Promise<MEMO> = FunPromise.resolve(initialValue);\n\t\t\treturn Promise.all(\n\t\t\t\t_.map(ary, async (it) => {\n\t\t\t\t\tconst result = await it;\n\t\t\t\t\tmemo = memo.then((newMemo) => handler(newMemo, result));\n\t\t\t\t})\n\t\t\t).then(async () => await memo);\n\t\t});\n\t}\n\n\t/**\n\t * Given a [[`PromisableIterable`]] and an initial value, `foldSeq` resolves each value provided and passes\n\t * each value through the `handler` function along with the current state of the `memo`.  The return from\n\t * `handler` becomes the `memo` input of the next round. When there are no more elements, returns the\n\t * final `memo` that was returned.\n\t *\n\t * This implementation maintains the particular order for the inputs to be processed through 'handler':\n\t * the fulfillment of the promise is processed in the order of the iterable.\n\t */\n\tstatic foldSeq<T, MEMO = Element<T>>(\n\t\tthem: PromisableIterable<T>,\n\t\tinitialValue: Promisable<MEMO>,\n\t\thandler\n\t): FunPromise<MEMO> {\n\t\treturn FunPromise.resolve(them).fold(initialValue, handler);\n\t}\n\n\t/**\n\t * `this.fold(initialValue, handler)` is the same as [[ FunPromise.fold | `FunPromise.fold(this, initialValue, handler)` ]].\n\t */\n\tfoldSeq<MEMO = Element<T>>(\n\t\tinitialValue: Promisable<MEMO>,\n\t\thandler: (memo: MEMO, nextItem: Element<T>) => Promisable<MEMO>\n\t): FunPromise<MEMO> {\n\t\treturn this.reduceArray((ary) => {\n\t\t\tlet memoPromise: Promise<MEMO> = FunPromise.resolve(initialValue);\n\t\t\twhile (!_.isEmpty(ary)) {\n\t\t\t\tconst nextPromise = ary.shift();\n\t\t\t\tmemoPromise = memoPromise.then(async (memo) =>\n\t\t\t\t\thandler(memo, await nextPromise)\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn memoPromise;\n\t\t});\n\t}\n\n\t/**\n\t * Given a [[`PromisableIterable`]], resolves each value provided and passes each value through the\n\t * `test` function, retaining only those for which the test returned `true`.\n\t *\n\t * The order of input elements is maintained, but not the resolution order.\n\t *\n\t * If the payload is not an array, then it is coerced into an array using\n\t * [`_.castArray` from Lodash](https://lodash.com/docs/4.17.15#castArray).\n\t */\n\tstatic filter<T>(them: PromisableIterable<T>, filter) {\n\t\treturn FunPromise.resolve(them).filter(filter);\n\t}\n\n\t/**\n\t * `this.filter(test)` is the same as [[ FunPromise.filter | `FunPromise.filter(this, test)` ]].\n\t */\n\tfilter(\n\t\ttest: (it: Element<T>) => Promisable<boolean>\n\t): FunPromise<Element<T>[]> {\n\t\treturn this.processArray(async (ary) => {\n\t\t\tconst testResults = await Promise.all(_.map(ary, test));\n\t\t\treturn _.filter(ary, (item, idx) => {\n\t\t\t\titem; // Need to refer to it in order to avoid a compile error.\n\t\t\t\treturn testResults[idx];\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Given a [[`PromisableIterable`]], resolves each value provided and passes each value through the\n\t * `test` function, retaining only those for which the test returned `true`.\n\t *\n\t * The order of input elements and the resultion order are maintained.\n\t *\n\t * If the payload is not an array, then it is coerced into an array using\n\t * [`_.castArray` from Lodash](https://lodash.com/docs/4.17.15#castArray).\n\t */\n\tstatic filterSeq<T>(them: PromisableIterable<T>, filter) {\n\t\treturn FunPromise.resolve(them).filterSeq(filter);\n\t}\n\n\t/**\n\t * `this.filterSeq(test)` is the same as [[ FunPromise.filterSeq | `FunPromise.filterSeq(this, test)` ]].\n\t */\n\tfilterSeq(\n\t\ttest: (it: Element<T>) => Promisable<boolean>\n\t): FunPromise<Element<T>[]> {\n\t\treturn this.processArray(async (ary) => {\n\t\t\tconst result = [];\n\t\t\twhile (!_.isEmpty(ary)) {\n\t\t\t\tconst it = ary.shift();\n\t\t\t\tif (await test(it)) result.push(it);\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\t/**\n\t * Classic `then`, but returning a `FunPromise`.\n\t */\n\tthen(onfulfilled, onrejected?) {\n\t\treturn FunPromise.wrap(this.wrapped.then(onfulfilled, onrejected));\n\t}\n\n\t/**\n\t * Classic `catch`, but returning a `FunPromise`.\n\t */\n\tcatch(handler) {\n\t\treturn FunPromise.wrap(this.wrapped.catch(handler));\n\t}\n\n\t/**\n\t * Classic `finally`, but returning a `FunPromise`.\n\t */\n\tfinally(handler) {\n\t\treturn FunPromise.wrap(this.wrapped.finally(handler));\n\t}\n\n\t/**\n\t * Like [[`catch`]], but any non-[[`Error`]] that was thrown is\n\t * wrapped in an `Error`. (I bet a lot of your code assumes that\n\t * an error was thrown, doesn't it?)\n\t *\n\t * If you do not pass an argument, then this simply creates a promise\n\t * that may either be the value on resolution or the error on rejection,\n\t * similar to [[`finally`]] but the promise state is resolved instead of\n\t * rejected.\n\t */\n\tcatchError<U = never>(\n\t\thandler: (reason: Error) => U extends never ? void : U = _.identity\n\t): FunPromise<T | U> {\n\t\treturn this.catch((reason?: unknown) => {\n\t\t\tif (_.isNil(reason)) {\n\t\t\t\tthrow new Error(`Promise was rejected without a reason`);\n\t\t\t} else if (isError(reason)) {\n\t\t\t\thandler(reason);\n\t\t\t} else {\n\t\t\t\thandler(\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t`Promise was rejected; expected Error, but saw: ${_.toString(\n\t\t\t\t\t\t\treason\n\t\t\t\t\t\t)} (${typeof reason})`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Allows you to \"tap\" into a chain and work with the result at that point in the chain without modifying the value.\n\t *\n\t * Note that if the handler provided throws an exception, that _will_ be propagated as the cause for rejecting, so\n\t * it's not _impossible_ for `tap` to change the state of the promise.\n\t */\n\ttap(handler: (result: T) => Promisable<void>): FunPromise<T> {\n\t\treturn this.then(async (result) => {\n\t\t\tawait handler(result);\n\t\t\treturn result;\n\t\t});\n\t}\n\n\t/**\n\t * Allows you to \"tap\" into the error handling of a chain and work with the rejection reason at that point in the chain without\n\t * changing the rejected state.  It leverages [[`FunPromise.catchError`]] to make your typing much nicer.\n\t *\n\t * Note that if the handler provided throws an exception, that _will_ be propagated as the cause for rejecting, so\n\t * it's not _impossible_ for `tapCatch` to change the state of the promise.\n\t */\n\ttapCatch(handler: (result: Error) => Promisable<void>): FunPromise<T> {\n\t\treturn this.catchError((e) =>\n\t\t\tFunPromise.try(() => handler(e)).finally(() => {\n\t\t\t\tthrow e;\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Allows you to \"tap\" into the chain and work with either the rejection reason or the resolved value.\n\t * It leverages [[`FunPromise.catchError`]] to make your typing much nicer.\n\t *\n\t * Note that if the handler provided throws an exception, that _will_ be propagated as the cause for rejecting, so\n\t * it's not _impossible_ for `tapFinally` to change the state of the promise.\n\t */\n\ttapFinally(handler: (result: T | Error) => Promisable<void>): FunPromise<T>;\n\ttapFinally(\n\t\thandler: (result: T) => Promisable<void>,\n\t\terrHandler: (result: Error) => Promisable<void>\n\t): FunPromise<T>;\n\ttapFinally(handler, errHandler?): FunPromise<T> {\n\t\treturn this.tap(handler).tapCatch(errHandler ?? handler);\n\t}\n\n\t/**\n\t * Sets the argument as the resolution value for the promise.\n\t */\n\treturn<U>(value: Promisable<U>): FunPromise<U> {\n\t\treturn FunPromise.wrap(this.wrapped.then(() => value));\n\t}\n\n\t/**\n\t * Converts a wrapped [[`Iterable`]] into an array.\n\t *\n\t * This method _mostly_ exists for the sake of type safety/sanity: it gets the value to [[ Element | `Element<T>[]` ]]\n\t * from a lot of weird places.\n\t */\n\tarrayify(): FunPromise<Element<T>[]> {\n\t\treturn FunPromise.wrap(\n\t\t\tthis.wrapped.then((iterable) => _.toArray(iterable) as Element<T>[])\n\t\t);\n\t}\n\n\t/**\n\t * Simplifies multiple layers of promise wrappers down to a single wrapper.\n\t *\n\t * This method exists solely for the sake of the type system: its behavior is actually implied in the `Promise/A+` spec.\n\t */\n\tsimplify(): FunPromise<Unpromise<T>> {\n\t\treturn (this as unknown) as FunPromise<Unpromise<T>>;\n\t}\n}\n"]}