{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/types.ts"],"names":[],"mappings":"AAAA;;;;;;;GAOG;AAyDH;;GAEG;AACH,MAAM,OAAO,WAAW;IACK;IAA5B,YAA4B,KAAQ;QAAR,UAAK,GAAL,KAAK,CAAG;IAAG,CAAC;IAExC,IAAI,MAAM;QACT,OAAO,WAAW,CAAC;IACpB,CAAC;CACD;AAED;;GAEG;AACH,MAAM,OAAO,SAAS;IACO;IAA5B,YAA4B,MAAe;QAAf,WAAM,GAAN,MAAM,CAAS;IAAG,CAAC;IAE/C,IAAI,MAAM;QACT,OAAO,UAAU,CAAC;IACnB,CAAC;CACD","sourcesContent":["/**\n * @format\n *\n * These are where we put all the type aliases, interfaces, and enumerations that are shared\n * between multiple things, or may be useful to use without us.\n *\n * @packageDocumentation\n */\n\n/// <reference lib=\"es2020.promise\" />\n\n/**\n * Provides the type of elements within an `Iterable`, which may be wrapped in one or more promises.\n * The element type is also unwrapped any promises.\n */\nexport type Item<T> = Unpromise<T> extends Array<infer U>\n\t? U\n\t: Unpromise<T> extends Iterable<infer U>\n\t? U\n\t: never;\n\n/**\n * Provides the type of the resolution value after unwrapping all the `PromiseLike` and [[`Promisable`]] interfaces (if any).\n */\nexport type Unpromise<T> = T extends PromiseLike<infer U>\n\t? Unpromise<U>\n\t: T extends Promisable<infer U>\n\t? U extends T\n\t\t? T\n\t\t: Unpromise<U>\n\t: T;\n\n/**\n * Something which can be resolved: that is, either a value or a promise of a value.\n */\nexport type Promisable<T> = T | PromiseLike<T>;\n\n/**\n * Guarantees that there is only one `Promise` wrapper.\n */\nexport type SimplifiedPromise<T> = Promise<Unpromise<T>>;\n\n/**\n * Guarantees that there is only one `PromiseLike` wrapper.\n */\nexport type SimplifiedPromiseLike<T> = PromiseLike<Unpromise<T>>;\n\n/**\n * Guarantees that there is at most one `PromiseLike` wrapper.\n */\nexport type SimplifiedPromisable<T> = Promisable<Unpromise<T>>;\n\n/**\n * An `Iterable` or a promise of an `Iterable`. Its elements are any mix of type `T` and/or `PromiseLike<T>`.\n * Used as a type for arguments.\n */\nexport type PromisableIterable<T> = Promisable<IterableOfPromisables<T>>;\n\n/**\n * Represents an `Iterable` that is not a promise but an actual value that is an `Iterable`,\n * although it may produce either values or promises of values or both.\n */\nexport type IterableOfPromisables<T> = Iterable<Promisable<T>>;\n\n/**\n * Represents a `PromiseSettledResult` value for a fulfilled promise.\n */\nexport class Fulfillment<T> implements PromiseFulfilledResult<T> {\n\tconstructor(public readonly value: T) {}\n\n\tget status(): \"fulfilled\" {\n\t\treturn \"fulfilled\";\n\t}\n}\n\n/**\n * Represents a `PromiseSettledResult` value for a rejected promise.\n */\nexport class Rejection implements PromiseRejectedResult {\n\tconstructor(public readonly reason: unknown) {}\n\n\tget status(): \"rejected\" {\n\t\treturn \"rejected\";\n\t}\n}\n\n/**\n * Equivalent to a `PromiseSettledResult`, but specific to our classes.\n */\nexport type Settlement<T> = PromiseSettledResult<T> &\n\t(Fulfillment<T> | Rejection);\n"]}