<!-- @format -->

# fun-promises

## A library for making Promises more friendly, fluent, and fun(ctional).

### What This Is Not

This is _not_ an implementation of [Promises/A+](https://promisesaplus.com/). It
is not a polyfill or a [ponyfill](https://github.com/sindresorhus/ponyfill). In
fact, it assumes that you have `Promise` available as a global, either through a
polyfill or natively.

### What This Is

This is a library that extends the native `Promise` implementation with a number
of useful utilities, so that your code is faster and easier. It is inspired by
libraries like [`bluebird`](http://bluebirdjs.com/) and
[`rsvp.js`](https://github.com/tildeio/rsvp.js/blob/master/README.md), except
without the overhead of providing its own `Promise` implementation. Native
promises have been competitive in performance since Node 10
([even `bluebird` says so](https://www.npmjs.com/package/bluebird#note)) but
there's a lot of functionality which native `Promises` don't supply. Fun
Promises gives you that better API without the overhead.

### Some Highlights

For more details on these APIs, see
[GitHub Pages](https://robertfischer.github.io/fun-promises/).

#### `Deferral` class

This is an inside-out promise: it gives you access to the `resolve` and `reject`
methods of the promise so that you can perform operations on them later, as well
as having accessor to query the state of `promise`.

#### `try`

Wrap your execution in a promise, so that even its invocation
[won't release Zalgo](https://blog.izs.me/2013/08/designing-apis-for-asynchrony).

```typescript
FunPromise.try(() => doSomething(explosivelyFailingParamCalculation()));
```

#### `catchError`

Like `catch`, but ensures that the argument is an `Error`. (You can throw
anything in JavaScript!)

```typescript
sketchyCall().catchError((e) =>
	console.warn(`Failed to make sketchyCall: ${e.message}`, e)
);
```

#### `tap`

This lets you take a look at a resolved value without risking changing it. This
is extremely useful for debugging log messages.

```typescript
someExpensiveOperation()
	.tap((value) => debug("Value from someExpensiveOperation", value))
	.then(/* ... */);
```

#### `race`

Fire off a bunch of promises and return whichever one resolves first. (The
results of any later-resolving promises are discarded.)

```typescript
getRelatedShows().race((someShow) => renderSuggestedShow(someShow));
```

#### `coalesce`

Given a bunch of functions that return either values or promises of values,
execute them sequentially and return the first one what resolves.

```typescript
FunPromise.coalesce([
	lookupUserInMemoryCache,
	lookupUserInRedisCache,
	lookupUserInDB,
]).then((data) => renderUserData(data));
```

That code is equivalent to:

```typescript
FunPromise.resolve([
	lookupUserInMemoryCache,
	lookupUserInRedisCache,
	lookupUserInDB,
])
	.coalesce()
	.then((data) => renderUserData);
```

### Conventions

#### Collection Methods and `*Seq` Methods

There are a number of collection methods provided, such as `fold`, `map`, and
`filter`. These methods assume that they are acting on a
`FunPromise<T extends Iterable<U>>`, and the type system will ensure that you
are if you're using Typescript: attempts to call those functions on something
that is not `Iterable` will end up with a return type of `FunPromise<never>`.
If, however, you circumvent the typing (eg: by using JavaScript to call the
method), then the resolved value of the `FunPromise` will be cast to an array
using [`_.castArray` from Lodash](https://lodash.com/docs/4.17.15#castArray),
which probably does what you want.

There are also methods whose names end in `*Seq`. These methods also operate on
a `FunPromise<T extends Iterable<U>>`. They are functionally identical to their
`Seq`-less counterparts, but with one additional guarantee: the first element of
the iterable will be forced to resolve and will be processed before ever looking
at the second element, and so on. This may be useful for debugging or other
times when you are particular about making sure one thing works before the next
occurs.

### Distributions

By default, your packager should automatically grab the appropriate distribution
through the `package.json` configuration within this library. If you're curious
or if you have a weird use case, then you have a few different flavors of the
codebase to choose from. All of these are generated by the same underlying code.

#### ESNext

Within `./dist/esnext` is the result of the Typescript compilation with the
["ESNext" `module` setting](https://www.typescriptlang.org/tsconfig#module) and
the ["ESNext" `target` setting](https://www.typescriptlang.org/tsconfig#target).
This is the base that is used to generate the rest of the files.

#### Browser-Based: CommonJS, ES Modules, Single File UMD

Within `./dist/browser` are three folders: `cjs` (CommonJS), `esm` (ESModules),
`min` (single file UMD for serving up, eg: over a CDN).

#### Node: CommonJS and ES Modules

Within `./dist/browser` are two folders: `cjs` (CommonJS) and `esm` (ESModules).

### Documentation

The full documentation (including this content) is available at
[GitHub Pages](https://robertfischer.github.io/fun-promises/).

### Contributing [ TODO ]

#### Design Philosophy [ TODO ]
